import { BlueBaseModuleRegistry, BlueBaseModuleRegistryInputItem, BlueBaseModuleRegistryItem } from './BlueBaseModuleRegistry';
import { MaybeArray, MaybeBlueBaseModule, MaybeThunk, Omit } from '../utils';
import { BlueBase } from '../BlueBase';
import { ItemCollection } from './Registry';
/**
 * Default priority for a filter.
 */
export declare const DEFAULT_HOOK_PRIORITY = 10;
/**
 * The handler function of a filter object. This is the function that is
 * called for each filter, during execution.
 *
 * This may or may not be an async function.
 *
 * @param value The input value
 * @param args Any arguments passed on to the listener by the caller
 * @param BB The BlueBase context
 *
 * @returns Original or mutated version of input value. May be a promise that resolves the value.
 */
export declare type FilterHandlerFn<T = any> = (value: T, args: {
    [key: string]: any;
}, BB: BlueBase) => T | Promise<T>;
/**
 * Properties of a Filter item.
 */
export interface FilterRegistryItemProps {
    /**
     * Priority of exeuction.
     *
     * @default 10
     */
    priority: number;
    /**
     * ID of event to subscribe to
     */
    event: string;
    [key: string]: any;
}
export declare type FilterRegistryItem = BlueBaseModuleRegistryItem<FilterHandlerFn> & FilterRegistryItemProps;
export interface FilterRegistryInputItem extends BlueBaseModuleRegistryInputItem<FilterHandlerFn> {
    /**
     * ID of event to subscribe to
     */
    event: string;
}
declare type ItemType = FilterRegistryItem;
declare type ItemInputType = FilterRegistryInputItem;
/**
 * Filter Type.
 */
export declare type Filter = FilterRegistryItemProps & {
    value: FilterHandlerFn;
};
/**
 * FilterInput.
 */
export declare type FilterInput = FilterRegistryInputItem;
export declare type FilterInputCollection = ItemCollection<FilterInput>;
/**
 * A nested filter collection.
 */
export declare type FilterNestedCollection<T = Omit<FilterInput, 'event'> | FilterHandlerFn> = MaybeThunk<{
    [event: string]: MaybeArray<MaybeBlueBaseModule<T>>;
}>;
/**
 * ðŸš‡ FilterRegistry
 */
export declare class FilterRegistry extends BlueBaseModuleRegistry<ItemType, ItemInputType> {
    /**
     * Registers a nested filter collection.
     *
     * @param collections
     */
    registerNestedCollection(collections?: FilterNestedCollection): Promise<void>;
    /**
     * Get all filters for a specific event
     * @param event
     */
    findAllByEvent(event: string): {
        [key: string]: FilterRegistryItem;
    };
    /**
     * Run all filter listeners in a waterfall.
     * Each listener function gets 3 arguments:
     * 	- value
     * 	- args
     * 	- context
     *
     * Each listener function is expected to return a value.
     *
     * Example Usage: BB.Filters.run('filter-name', val, args);
     *
     * @param eventName Name of the filter
     * @param value Initial value to send to the filter
     * @param args Any extra arguments to pass to the filter
     */
    run<T = any>(eventName: string, initialValue: T, args?: {
        [key: string]: any;
    }): Promise<T>;
    /**
     * Typeguard to check a given object is an input value
     * @param value
     */
    protected isInputValue(value: any): value is ItemInputType['value'];
    /**
     * Typeguard to check a given object is a input item
     * @param item
     */
    protected isInputItem(item: any): item is ItemInputType;
    /**
     * Convert any input value to an item. This is where you transform inputs and add defualts
     * @param key
     * @param partial
     */
    protected createItem(key: string, partial: any): FilterRegistryItem;
}
export {};
