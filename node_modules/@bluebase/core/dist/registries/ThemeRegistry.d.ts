import { BlueBaseModuleRegistry, BlueBaseModuleRegistryInputItem, BlueBaseModuleRegistryItem } from './BlueBaseModuleRegistry';
import { ThemeValue, ThemeValueInput } from '../themes';
import { ItemCollection } from './Registry';
export interface ThemeRegistryItemExtras {
    /**
     * Name of theme.
     *
     * We put it in meta so we can show the name in menu een without downloading
     * the whole theme.
     */
    name: string;
    /**
     * Theme mode: Either light or dark.
     */
    mode: 'light' | 'dark';
    /**
     * Sometimes a user wants to switch to the light/dark version of the same theme.
     * This property has the slug of that theme. For example, if this is a light theme,
     * this property will have the slug of the dark version, and vice versa.
     */
    alternate?: string;
    key: string;
}
export declare type ThemeRegistryItem = BlueBaseModuleRegistryItem<ThemeValue> & ThemeRegistryItemExtras;
export declare type ThemeRegistryInputItem = BlueBaseModuleRegistryInputItem<ThemeValueInput>;
declare type ItemType = ThemeRegistryItem;
declare type ItemInputType = ThemeRegistryInputItem;
export declare type Theme = ThemeRegistryItemExtras & ThemeValue;
export declare type ThemeInput = ThemeRegistryInputItem;
export declare type ThemeCollection = ItemCollection<ThemeInput>;
/**
 * ðŸŽ¨ ThemeRegistry
 */
export declare class ThemeRegistry extends BlueBaseModuleRegistry<ItemType, ItemInputType> {
    /**
     * Returns a Promise that resolves a Theme
     * @param keys
     */
    resolve(...keys: string[]): Promise<Theme>;
    /**
     * Get alternate version of current theme
     * @param key
     */
    resolveAlternate(key: string): Promise<Theme>;
    /**
     * Convert any input value to an item. This is where you transform inputs and add defualts
     * @param key
     * @param partial
     */
    protected createItem(key: string, partial: any): ThemeRegistryItem;
}
export {};
