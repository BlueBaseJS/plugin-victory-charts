"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const BlueBaseModuleRegistry_1 = require("./BlueBaseModuleRegistry");
const utils_1 = require("../utils");
const lodash_isfunction_1 = tslib_1.__importDefault(require("lodash.isfunction"));
const lodash_isnil_1 = tslib_1.__importDefault(require("lodash.isnil"));
/**
 * Default priority for a filter.
 */
exports.DEFAULT_HOOK_PRIORITY = 10;
/**
 * ðŸš‡ FilterRegistry
 */
class FilterRegistry extends BlueBaseModuleRegistry_1.BlueBaseModuleRegistry {
    /**
     * Registers a nested filter collection.
     *
     * @param collections
     */
    async registerNestedCollection(collections = {}) {
        // If filters field is a thunk, then call the thunk function
        collections = utils_1.resolveThunk(collections, this.BB);
        // Extract filter names. These are events that are being subscribed to
        const eventNames = Object.keys(collections);
        // Iterate over each filter name
        for (const eventName of eventNames) {
            // Extract collection for each event
            const singleCollection = utils_1.getDefiniteArray(collections[eventName]);
            for (let item of singleCollection) {
                // Make sure item is resolved if its a promise
                item = await utils_1.getDefiniteBlueBaseModule(item);
                // Register each item indivitually
                if (this.isInputValue(item)) {
                    await this.register({ event: eventName, value: item });
                    continue;
                }
                const newItem = Object.assign({ event: eventName }, item);
                if (!this.isInputItem(newItem)) {
                    throw Error(`Could not register Filter. Reason: Input is not a filter item.`);
                }
                await this.register(newItem);
            }
        }
    }
    /**
     * Get all filters for a specific event
     * @param event
     */
    findAllByEvent(event) {
        return this.filter((_value, _key, item) => item.event === event);
    }
    /**
     * Run all filter listeners in a waterfall.
     * Each listener function gets 3 arguments:
     * 	- value
     * 	- args
     * 	- context
     *
     * Each listener function is expected to return a value.
     *
     * Example Usage: BB.Filters.run('filter-name', val, args);
     *
     * @param eventName Name of the filter
     * @param value Initial value to send to the filter
     * @param args Any extra arguments to pass to the filter
     */
    async run(eventName, initialValue, args = {}) {
        let value = initialValue;
        // Get all filter items registered for this event
        const filterItems = Object.values(this.findAllByEvent(eventName));
        // If there are no filter items registered for this filter
        if (filterItems.length === 0) {
            return value;
        }
        // Sort items based on priority
        filterItems.sort((a, b) => a.priority - b.priority);
        // Run waterfall
        for (const item of filterItems) {
            // Resolve handler functions
            const handler = await item.value;
            // Check if handler is a valid function
            if (!lodash_isfunction_1.default(handler)) {
                throw Error(`Handler of FilterListener "${item.key}" in filter "${eventName}" is not a function.`);
            }
            // Execute filter function
            const result = await handler(value, Object.assign({}, args), this.BB);
            // If the filter didn't return any value, return previous accumulator
            if (typeof result === 'undefined' && typeof initialValue !== 'undefined') {
                // if result of current iteration is undefined, don't pass it on
                this.BB.Logger.warn(`FilterListener "${item.key}" in filter "${eventName}" did not return a result.`, item);
            }
            else {
                value = result;
            }
        }
        return value;
    }
    /**
     * Typeguard to check a given object is an input value
     * @param value
     */
    isInputValue(value) {
        return typeof value === 'function';
    }
    /**
     * Typeguard to check a given object is a input item
     * @param item
     */
    isInputItem(item) {
        return !lodash_isnil_1.default(item.value) && !lodash_isnil_1.default(item.event);
    }
    /**
     * Convert any input value to an item. This is where you transform inputs and add defualts
     * @param key
     * @param partial
     */
    createItem(key, partial) {
        return super.createItem(key, Object.assign({ priority: exports.DEFAULT_HOOK_PRIORITY }, partial));
    }
}
exports.FilterRegistry = FilterRegistry;
