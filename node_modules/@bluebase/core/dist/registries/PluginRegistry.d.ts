import { BlueBaseModuleRegistry, BlueBaseModuleRegistryInputItem, BlueBaseModuleRegistryItem } from './BlueBaseModuleRegistry';
import { DynamicIconProps, RouteConfig } from '../components/';
import { MaybeArray, MaybeThunk } from '../utils';
import { ComponentCollection } from './ComponentRegistry';
import { ConfigCollection } from './ConfigRegistry';
import { FilterNestedCollection } from './FilterRegistry';
import { ItemCollection } from './Registry';
import { ThemeCollection } from './ThemeRegistry';
export declare type PluginCategory = 'app' | 'store' | 'router' | 'logging' | 'theme' | 'analytics' | string;
export interface PluginValue {
    components: ComponentCollection;
    filters: FilterNestedCollection;
    themes: ThemeCollection;
    routes?: MaybeThunk<MaybeArray<RouteConfig>>;
}
export declare type PluginValueInput = Partial<PluginValue>;
export interface PluginRegistryItemExtras {
    /**
     * Name of the plugin.
     *
     * We put it in meta so we can show the name in menu een without downloading
     * the whole plugin.
     */
    name: string;
    /** Plugin categories */
    categories?: PluginCategory[];
    /** Plugin description */
    description?: string;
    /** Plugin version */
    version?: string;
    /** Plugin Icon Props */
    icon?: MaybeThunk<DynamicIconProps>;
    /** Is this plugin currently enabled/ */
    enabled: boolean;
    defaultConfigs: ConfigCollection;
    [key: string]: any;
}
export declare type PluginRegistryItem = BlueBaseModuleRegistryItem<PluginValue> & PluginRegistryItemExtras;
export declare type PluginRegistryInputItem = BlueBaseModuleRegistryInputItem<PluginValueInput>;
declare type ItemType = PluginRegistryItem;
declare type ItemInputType = PluginRegistryInputItem;
export declare type Plugin = PluginRegistryItemExtras & PluginValue;
export declare type PluginInput = PluginRegistryInputItem;
export declare type PluginCollection = ItemCollection<PluginInput>;
export declare function inputToPlugin(plugin: PluginInput): Plugin;
/**
 * Creates a BlueBase plugin from input params
 * @param plugin
 */
export declare function createPlugin(plugin: Partial<Plugin>): PluginInput;
/**
 * ðŸ”Œ PluginRegistry
 */
export declare class PluginRegistry extends BlueBaseModuleRegistry<ItemType, ItemInputType> {
    /**
     * Returns a Promise that resolves a Plugin
     * @param keys
     */
    resolve(...keys: string[]): Promise<Plugin>;
    /**
     * Checks if a plugin is enabled
     * @param key
     */
    isEnabled(key: string): boolean;
    /**
     * Enable a plugin
     * @param key
     */
    enable(key: string): Promise<void>;
    /**
     * Disable a plugin
     * @param key
     */
    disable(key: string): Promise<void>;
    /**
     * Checks if a config belongs to a plugin. Does so by checking 2 things:
     *
     * 1. Does the config start with 'plugin.{key}.'?
     * 2. Does the config exist in defaultConfigs property of the plugin?
     *
     * Returns true if any of the above are true, otherwise returns false
     *
     * @param key
     */
    hasConfig(key: string, config: string): boolean;
    /**
     * Creates a map of routes for each plugin
     *
     * Ignores plugins if:
     *
     * - Plugin is not enabled
     * - Plugin is not resolved
     */
    getRouteMap(prefixPluginKey?: boolean): {
        [key: string]: RouteConfig[];
    };
    /**
     * Register a collection of items.
     * @param collection
     */
    registerCollection(collection?: ItemCollection<ItemInputType>): Promise<void>;
    /**
     * Convert any input value to an item. This is where you transform inputs and add defualts
     * @param key
     * @param partial
     */
    protected createItem(key: string, partial: any): ItemType;
    /**
     * Typeguard to check a given object is an input value
     * @param value
     */
    protected isInputValue(value: any): value is PluginRegistryInputItem['value'];
}
export {};
