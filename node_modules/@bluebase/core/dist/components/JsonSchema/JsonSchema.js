"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const json_schema_parser_1 = require("../../lib/json-schema-parser");
const Context_1 = require("../../Context");
const index_1 = require("../../index");
const react_1 = tslib_1.__importDefault(require("react"));
const getComponent = (BB) => {
    return ({ component }) => {
        return BB.Components.has(String(component)) ? BB.Components.resolve(String(component)) : null;
    };
};
/**
 * # üç± JsonSchema
 *
 * Renders a Component based on JSON schema. This allows developers to create dynamic
 * layouts in their apps, and even save the schema to databases.
 *
 * Moreover, it also makes that schema filter-able. So that any plugin can modify that schema
 * on runtime.
 *
 * ## Usage:
 * ```jsx
 * <JsonSchema
 * 	filter="content-filter"
 * 	args={{ style: { color: 'blue' } }}
 *  schema={{
 * 	 component: 'Text',
 * 	 props: {
 * 		 style: {
 * 			 color: 'red'
 * 		 }
 * 	 },
 * 	 text: 'This is the page content.',
 *  }
 * } />
 * ```
 */
class JsonSchema extends react_1.default.PureComponent {
    render() {
        const BB = this.context;
        const { filter, schema, args } = this.props;
        const parser = new json_schema_parser_1.JsonSchemaParser(getComponent(BB));
        // There's no filter, we don't need to do complex async handling
        if (!filter) {
            return parser.parseSchema(schema);
        }
        const children = (loadedSchema) => parser.parseSchema(loadedSchema);
        return (react_1.default.createElement(index_1.BlueBaseFilter, { filter: filter, value: schema, args: args, children: children }));
    }
}
JsonSchema.contextType = Context_1.BlueBaseContext;
exports.JsonSchema = JsonSchema;
