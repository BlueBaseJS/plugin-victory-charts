"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const getComponent_1 = require("../getComponent");
const react_1 = tslib_1.__importStar(require("react"));
const Context_1 = require("../Context");
const deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
/**
 * This is the context where BlueBase theme is stored.
 */
exports.ThemeContext = react_1.createContext(undefined);
/**
 * BlueBase theme consumer.
 */
exports.ThemeConsumer = exports.ThemeContext.Consumer;
/**
 * ðŸŽ¨ ThemeProvider
 */
class ThemeProvider extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.state = {
            loading: true,
        };
    }
    async componentWillMount() {
        const BB = this.context;
        const { theme, overrides = {} } = this.props;
        this.setTheme(theme, overrides, BB);
        // Subscribe to theme config updates
        if (!theme) {
            this.subscriptionId = BB.Configs.subscribe('theme.name', (value) => {
                this.setTheme(value, overrides, BB);
            });
        }
    }
    componentWillUnmount() {
        const BB = this.context;
        // Unsubscribe from theme config updates
        if (this.subscriptionId) {
            BB.Configs.unsubscribe('theme.name', this.subscriptionId);
            delete this.subscriptionId;
        }
    }
    /**
     * Sets a theme to Provider's state. If a theme key is given, it is used,
     * otherwise global theme is used.
     *
     * @param slug
     * @param BB
     */
    async setTheme(slug, overrides = {}, BB) {
        if (this.state.loading !== true) {
            this.setState({ loading: true });
        }
        const key = slug || BB.Configs.getValue('theme.name');
        try {
            const theme = await BB.Themes.resolve(key);
            this.setState({ theme: deepmerge_1.default(theme, overrides), loading: false });
        }
        catch (error) {
            this.setState({
                error: Error(`Could not change theme. Reason: Theme with the key "${key}" does not exist.`),
                loading: false,
            });
        }
    }
    render() {
        const BB = this.context;
        const { loading, error, theme } = this.state;
        const retry = () => this.setTheme(this.props.theme, this.props.overrides, BB);
        if (error) {
            return react_1.default.createElement(getComponent_1.ErrorState, { error: error, retry: retry });
        }
        if (loading) {
            return react_1.default.createElement(getComponent_1.LoadingState, { retry: retry });
        }
        if (!theme) {
            return react_1.default.createElement(getComponent_1.ErrorState, { error: Error('Could not load theme.') });
        }
        const value = {
            changeTheme: (slug) => { BB.Configs.setValue('theme.name', slug); },
            theme
        };
        return (react_1.default.createElement(exports.ThemeContext.Provider, { value: value, children: this.props.children }));
    }
}
ThemeProvider.contextType = Context_1.BlueBaseContext;
exports.ThemeProvider = ThemeProvider;
